# (c) 2015-2016 Acellera Ltd http://www.acellera.com
# All Rights Reserved
# Distributed under HTMD Software License Agreement
# No redistribution in whole or part
#
from __future__ import print_function

import numpy as np
import os.path as path
import os
import re
import shutil
import textwrap

from subprocess import call

from htmd.home import home
from htmd.molecule.molecule import Molecule
from htmd.molecule.util import _missingChain, _missingSegID
from htmd.builder.builder import detectDisulfideBonds
from htmd.builder.ionize import ionize as ionizef, ionizePlace
from htmd.vmdviewer import getVMDpath

import logging
logger = logging.getLogger(__name__)


def listFiles():
    """ Lists all available Charmm topologies and parameter files
    """
    charmmdir = path.join(home(), 'builder', 'charmmfiles')  # maybe just lookup current module?
    topos = os.listdir(path.join(charmmdir, 'top'))
    params = os.listdir(path.join(charmmdir, 'par'))
    print('---- Topologies files list: ' + path.join(charmmdir, 'top', '') + ' ----')
    for t in topos:
        print('top/' + t)
    print('---- Parameters files list: ' + path.join(charmmdir, 'par', '') + ' ----')
    for p in params:
        print('par/' + p)


def build(mol, topo=None, param=None, prefix='structure', outdir='./', ionize=True, caps=None, execute=True, saltconc=0,
          saltanion=None, saltcation=None, disulfide=None, patches=[], vmd=None):
    """ Builds a system for CHARMM

    Uses VMD and psfgen to build a system for CHARMM. Additionally it allows for ionization and adding of disulfide bridges.

    Parameters
    ----------
    mol : :class:`Molecule <htmd.molecule.molecule.Molecule>` object
        The Molecule object containing the system
    topo : list of str
        A list of topology `rtf` files. Default: ['top/top_all22star_prot.rtf', 'top/top_all36_lipid.rtf', 'top/top_water_ions.rtf']
    param : list of str
        A list of parameter `prm` files. Default: ['par/par_all22star_prot.prm', 'par/par_all36_lipid.prm', 'par/par_water_ions.prm']
    prefix : str
        The prefix for the generated pdb and psf files
    outdir : str
        The path to the output directory
    ionize : bool
        Enable or disable ionization
    caps : dict
        A dictionary with keys segids and values lists of strings describing the caps of that segment.
        e.g. caps['P'] = ['first ACE', 'last CT2']. Default: will apply ACE and CT2 caps to proteins and none caps
        to the rest
    execute : bool
        Disable building. Will only write out the vmd script needed by psfgen. Does not include ionization.
    saltconc : float
        Salt concentration (in Molar) to add to the system after neutralization.
    saltanion : {'CLA'}
        The anion type. Please use only CHARMM ion atom names.
    saltcation : {'SOD', 'MG', 'POT', 'CES', 'CAL', 'ZN2'}
        The cation type. Please use only CHARMM ion atom names.
    disulfide : list of :class:`DisulfideBridge <htmd.builder.builder.DisulfideBridge>` objects
        If None it will guess disulfide bonds. Otherwise provide a list of `DisulfideBridge` objects.
    patches : list of str
        Any further patches the user wants to apply
    vmd : str
        Path to vmd executable used to build for CHARMM with psfgen

    Returns
    -------
    molbuilt : :class:`Molecule <htmd.molecule.molecule.Molecule>` object
        The built system in a Molecule object

    Example
    -------
    >>> charmm.listFiles()
    >>> topos  = ['top/top_all22star_prot.rtf', './benzamidine.rtf']
    >>> params = ['par/par_all22star_prot.prm', './benzamidine.prm']
    >>> molbuilt = charmm.build(mol, topo=topos, param=params, outdir='/tmp/build', saltconc=0.15)
    """
    mol = mol.copy()
    vmd = getVMDpath(vmd=vmd)
    if shutil.which(vmd) is None:
        raise NameError('Could not find executable: `' + vmd + '` in the PATH. Cannot build for CHARMM.')
    if not os.path.isdir(outdir):
        os.makedirs(outdir)
    if topo is None:
        topo = _defaultTopo()
    if param is None:
        param = _defaultParam()
    if caps is None:
        caps = _defaultCaps(mol)

    #_missingChain(mol)
    _missingSegID(mol)
    #_checkProteinGaps(mol)

    if isinstance(patches, str):
        patches = [patches]
	# Find protonated residues and add patches for them
    patches += _protonationPatches(mol)

    f = open(path.join(outdir, 'build.vmd'), 'w')
    f.write('# psfgen file generated by charmm.build\n')
    f.write('package require psfgen;\n')
    f.write('psfcontext reset;\n\n')

    # Copying and printing out the topologies
    charmmdir = path.join(home(), 'builder', 'charmmfiles')
    for i in range(len(topo)):
        if topo[i][0] != '.' and path.isfile(path.join(charmmdir, topo[i])):
            topo[i] = path.join(charmmdir, topo[i])
        shutil.copy(topo[i], outdir)
        f.write('topology ' + path.basename(topo[i]) + '\n')
    f.write('\n')

    _printAliases(f)

    # Printing out segments
    logger.info('Writing out segments.')
    segments = _getSegments(mol)
    for seg in segments:
        pdbname = 'segment' + seg + '.pdb'
        mol.write(path.join(outdir, pdbname), sel='segid '+seg)

        segatoms = mol.atomselect('segid {}'.format(seg))
        segwater = mol.atomselect('segid {} and water'.format(seg))

        f.write('segment ' + seg + ' {\n')
        if np.all(segatoms == segwater):  # If segment only contains waters, set: auto none
            f.write('\tauto none\n')
        f.write('\tpdb ' + pdbname + '\n')
        if caps is not None and seg in caps:
            for c in caps[seg]:
                f.write('\t' + c + '\n')
        f.write('}\n')
        f.write('coordpdb ' + pdbname + ' ' + seg + '\n\n')

    # Printing out patches for the disulfide bridges
    if disulfide is None:
        disulfide = detectDisulfideBonds(mol)

    if len(disulfide) != 0:
        for d in disulfide:
            f.write('patch DISU {}:{} {}:{}\n'.format(d.segid1, d.resid1, d.segid2, d.resid2))
        f.write('\n')

    # Printing out extra patches
    if len(patches) != 0:
        for p in patches:
            f.write(p + '\n')
        f.write('\n')

    f.write('guesscoord\n')
    f.write('writepsf ' + prefix + '.psf\n')
    f.write('writepdb ' + prefix + '.pdb\n')
    f.write('quit\n')
    f.close()

    if param is not None:
        _charmmCombine(param, path.join(outdir, 'parameters'))

    molbuilt = None
    if execute:
        logpath = os.path.abspath('{}/log.txt'.format(outdir))
        logger.info('Starting the build.')
        currdir = os.getcwd()
        os.chdir(outdir)
        f = open(logpath, 'w')
        call([vmd, '-dispdev', 'text', '-e', './build.vmd'], stdout=f)
        f.close()
        _logParser(logpath)
        os.chdir(currdir)
        logger.info('Finished building.')

        if path.isfile(path.join(outdir, 'structure.pdb')) and path.isfile(path.join(outdir, 'structure.psf')):
            molbuilt = Molecule(path.join(outdir, 'structure.pdb'))
            molbuilt.read(path.join(outdir, 'structure.psf'))
        else:
            raise NameError('No structure pdb/psf file was generated. Check {} for errors in building.'.format(logpath))

        if ionize:
            shutil.move(path.join(outdir, 'structure.pdb'), path.join(outdir, 'structure.noions.pdb'))
            shutil.move(path.join(outdir, 'structure.psf'), path.join(outdir, 'structure.noions.psf'))
            totalcharge = np.sum(molbuilt.charge)
            nwater = np.sum(molbuilt.atomselect('water and noh'))
            anion, cation, anionatom, cationatom, nanion, ncation = ionizef(totalcharge, nwater, saltconc=saltconc, ff='charmm', anion=saltanion, cation=saltcation)
            newmol = ionizePlace(mol, anion, cation, anionatom, cationatom, nanion, ncation)
            # Redo the whole build but now with ions included
            return build(newmol, topo=topo, param=param, prefix=prefix, outdir=outdir, ionize=False, caps=caps,
                         execute=execute, saltconc=saltconc, disulfide=disulfide, patches=patches, vmd=vmd)
    return molbuilt


def _getSegments(mol):
    # Calculate unique segments but keep sorting
    indexes = np.unique(mol.segid, return_index=True)[1]
    uqseg = [mol.segid[index] for index in sorted(indexes)]
    return uqseg


def _printAliases(f):
    lines = '''
        # Aliases
        pdbalias residue G GUA
        pdbalias residue C CYT
        pdbalias residue A ADE
        pdbalias residue T THY
        pdbalias residue U URA

        foreach bp { GUA CYT ADE THY URA } {
            pdbalias atom $bp "O5\*" O5'
            pdbalias atom $bp "C5\*" C5'
            pdbalias atom $bp "O4\*" O4'
            pdbalias atom $bp "C4\*" C4'
            pdbalias atom $bp "C3\*" C3'
            pdbalias atom $bp "O3\*" O3'
            pdbalias atom $bp "C2\*" C2'
            pdbalias atom $bp "O2\*" O2'
            pdbalias atom $bp "C1\*" C1'
        }

        pdbalias atom ILE CD1 CD
        pdbalias atom SER HG HG1
        pdbalias residue HIS HSD

        # Heme aliases
        pdbalias residue HEM HEME
        pdbalias atom HEME "N A" NA
        pdbalias atom HEME "N B" NB
        pdbalias atom HEME "N C" NC
        pdbalias atom HEME "N D" ND

        # Water aliases
        pdbalias residue HOH TIP3
        pdbalias atom TIP3 O OH2

        # Ion aliases
        pdbalias residue K POT
        pdbalias atom K K POT
        pdbalias residue ICL CLA
        pdbalias atom ICL CL CLA
        pdbalias residue INA SOD
        pdbalias atom INA NA SOD
        pdbalias residue CA CAL
        pdbalias atom CA CA CAL
        pdbalias residue ZN ZN2

        # Other aliases
        pdbalias atom LYS 1HZ HZ1
        pdbalias atom LYS 2HZ HZ2
        pdbalias atom LYS 3HZ HZ3

        pdbalias atom ARG 1HH1 HH11
        pdbalias atom ARG 2HH1 HH12
        pdbalias atom ARG 1HH2 HH21
        pdbalias atom ARG 2HH2 HH22

        pdbalias atom ASN 1HD2 HD21
        pdbalias atom ASN 2HD2 HD22

        # Aliases for Maestro residues
        pdbalias residue GLH GLU
        pdbalias residue ASH ASP
        pdbalias residue LYN LYS
        pdbalias residue HIE HSE
        pdbalias residue HID HSD
        pdbalias residue HIP HSP
        pdbalias residue CYX CYS
        pdbalias residue WAT TIP3

        # Generated by gen_psfaliases.py (Toni) on 2016-03-11 10:21
        pdbalias atom ALA H HN
        pdbalias atom ARG H HN
        pdbalias atom ARG HB3 HB1
        pdbalias atom ARG HG3 HG1
        pdbalias atom ARG HD3 HD1
        pdbalias atom ASP H HN
        pdbalias atom ASP HB3 HB1
        pdbalias atom ASN H HN
        pdbalias atom ASN HB3 HB1
        pdbalias atom CYS H HN
        pdbalias atom CYS HB3 HB1
        pdbalias atom GLU H HN
        pdbalias atom GLU HB3 HB1
        pdbalias atom GLU HG3 HG1
        pdbalias atom GLN H HN
        pdbalias atom GLN HB3 HB1
        pdbalias atom GLN HG3 HG1
        pdbalias atom GLY H HN
        pdbalias atom GLY HA3 HA1
        pdbalias atom HIS H HN
        pdbalias atom HIS HB3 HB1
        pdbalias atom ILE H HN
        pdbalias atom ILE HG13 HG11
        pdbalias atom ILE HD11 HD1
        pdbalias atom ILE HD12 HD2
        pdbalias atom ILE HD13 HD3
        pdbalias atom LEU H HN
        pdbalias atom LEU HB3 HB1
        pdbalias atom LYS H HN
        pdbalias atom LYS HB3 HB1
        pdbalias atom LYS HG3 HG1
        pdbalias atom LYS HD3 HD1
        pdbalias atom LYS HE3 HE1
        pdbalias atom MET H HN
        pdbalias atom MET HB3 HB1
        pdbalias atom MET HG3 HG1
        pdbalias atom PHE H HN
        pdbalias atom PHE HB3 HB1
        pdbalias atom PRO H2 HT2
        pdbalias atom PRO H3 HT1
        pdbalias atom PRO HB3 HB1
        pdbalias atom PRO HG3 HG1
        pdbalias atom PRO HD3 HD1
        pdbalias atom SER H HN
        pdbalias atom SER HB3 HB1
        pdbalias atom THR H HN
        pdbalias atom TRP H HN
        pdbalias atom TRP HB3 HB1
        pdbalias atom TYR H HN
        pdbalias atom TYR HB3 HB1
        pdbalias atom VAL H HN
    '''
    f.write(textwrap.dedent(lines))


def _defaultTopo():
    return ['top/top_all22star_prot.rtf', 'top/top_all36_lipid.rtf', 'top/top_water_ions.rtf']


def _defaultParam():
    return ['par/par_all22star_prot.prm', 'par/par_all36_lipid.prm', 'par/par_water_ions.prm']


def _defaultCaps(mol):
    # neutral for protein, nothing for any other segment
    # of course this might not be ideal for protein which require charged terminals
    segsProt = np.unique(mol.get('segid', sel='protein'))
    segsNonProt = np.unique(mol.get('segid', sel='not protein'))
    intersection = np.intersect1d(segsProt, segsNonProt)
    if len(intersection) != 0:
        raise NameError('Segments {} contain both protein and non-protein atoms. Please assign separate segments to them.'.format(intersection))

    caps = dict()
    for s in segsProt:
        nter, cter = _removeCappedResidues(mol, s)
        caps[s] = ['first {}'.format(nter), 'last {}'.format(cter)]
    for s in segsNonProt:
        caps[s] = ['first none', 'last none']
    return caps


def _removeCappedResidues(mol, seg):
    # Default caps for charmm
    nter = 'ACE'
    cter = 'CT2'

    # Mapping from various residue caps to charmm patches
    '''
    CHARMM patches:
    # N-terminus patches
    NTER         1.00 ! standard N-terminus
    GLYP         1.00 ! Glycine N-terminus
    PROP         1.00 ! Proline N-Terminal
    ACE          0.00 ! acetylated N-terminus
    ACED         0.00 ! acetylated N-terminus (to create dipeptide)
    ACP          0.00 ! acetylated N-terminus for proline
    ACPD         0.00 ! acetylated N-terminus for proline (to create dipeptide)
    NNEU         0.00 ! neutral N-terminus; charges from LSN
    # C-Terminus patches
    CTER        -1.00 ! standard C-terminus
    CNEU         0.00 ! protonated (neutral) C-terminu, charges from ASPP
    CTP          0.00 ! protonated C-terminus
    CT1          0.00 ! methylated C-terminus from methyl acetate
    CT2          0.00 ! amidated C-terminus
    CT3          0.00 ! N-Methylamide C-terminus
    '''

    ntercaps = {'ACE': 'ACE'}
    ctercaps = {'NMA': 'CT3'}

    # If caps already exist, remove them and convert them to charmm caps
    for n in ntercaps:
        sel = 'segid {} and resname {}'.format(seg, n)
        asel = mol.atomselect(sel)
        if np.sum(asel) != 0:
            mol.remove(asel, _logger=False)
            nter = ntercaps[n]
            break  # I expect only one capped n-terminal residue in one segment!
    for c in ctercaps:
        sel = 'segid {} and resname {}'.format(seg, c)
        asel = mol.atomselect(sel)
        if np.sum(asel) != 0:
            mol.remove(asel, _logger=False)
            cter = ctercaps[c]
            break  # I expect only one capped c-terminal residue in one segment!
    return nter, cter


# Mapping Maestro protonated residue names to CHARMM patches
def _protonationPatches(mol):
    protonations = {'GLH': 'GLUP', 'ASH': 'ASPP', 'LYN': 'LSN'}
    # TODO: Do I need to rename before applying patch?
    patches = []

    for pro in protonations:
        pseg = mol.get('segid', sel='resname {} and name CA'.format(pro))
        pres = mol.get('resid', sel='resname {} and name CA'.format(pro))
        if len(pseg) == 0:
            continue
        patch = 'patch {}'.format(protonations[pro])
        for r in range(len(pseg)):
            patch += ' {}:{}'.format(pseg[r], pres[r])
        patches.append(patch)
    return patches


def _charmmCombine(prmlist, outfile):
    """ Combines CHARMM parameter files.

    Parameters
    ----------
    prmlist
    outfile

    Returns
    -------

    """
    # Process parameter files
    prm_list = ["!COMMENTS\n", "!ATOMS\n", "BONDS\n", "ANGLES\n", "DIHEDRALS\n", "IMPROPER\n", "CMAP\n", "NONBONDED\n", "NBFIX\n", "HBOND\n"]

    charmmdir = path.join(home(), 'builder', 'charmmfiles')
    for myfile in prmlist:
        if myfile[0] != '.' and path.isfile(path.join(charmmdir, myfile)):
            myfile = path.join(charmmdir, myfile)
        if not path.isfile(myfile):
            raise NameError(myfile + ' file does not exist. Cannot create combined parameter file.')
        fn = os.path.basename(myfile)
        fh = open(myfile, "r")
        context = 0
        for line in fh:
            if re.search(r'^ATOMS', line):
                context = 1
                prm_list[context] += _sec_name(fn)
            elif re.search(r'^BOND', line):
                context = 2
                prm_list[context] += _sec_name(fn)
            elif re.search(r'^ANGL', line):
                context = 3
                prm_list[context] += _sec_name(fn)
            elif re.search(r'^DIHE', line) or re.search(r'^THET', line):
                context = 4
                prm_list[context] += _sec_name(fn)
            elif re.search(r'^IMPR', line) or re.search(r'^IMPH', line):
                context = 5
                prm_list[context] += _sec_name(fn)
            elif re.search(r'^CMAP', line) or re.search(r'^NBON', line):
                context = 6
                prm_list[context] += _sec_name(fn)
            elif re.search(r'^NONB', line):
                context = 7
                prm_list[context] += _sec_name(fn)
            elif re.search(r'^NBFI', line):
                context = 8
                prm_list[context] += _sec_name(fn)
            elif re.search(r'^HBON', line):
                context = 9
                prm_list[context] += _sec_name(fn)
            else:
                if context == 0: # COMMENTS
                    if re.search(r'^\s*\!+',line,re.I) or re.search(r'^\s*\*+',line,re.I):
                        prm_list[context] += line
                    else:
                        prm_list[context] += "!"+line
                elif context == 1: # ATOMS
                    if re.search(r'^\s*\!+',line,re.I):
                        prm_list[context] += line
                    else:
                        prm_list[context] += "!"+line
                elif context == 2: # BONDS
                    if re.search(r'^\s*\!+',line) or \
                       re.search(r'^\s*$',line) or \
                       re.search(r'^\s*[A-Z0-9a-z_]+\s+[A-Z0-9a-z_]+\s+[0-9\.\-]+\s+',line):
                        prm_list[context] += line
                    else:
                        prm_list[context] += "!"+line
                elif context == 3: # ANGLES
                    if re.search(r'^\s*\!+',line,re.I) or \
                       re.search(r'^\s*$',line) or \
                       re.search(r'^\s*[A-Z0-9a-z_]+\s+[A-Z0-9a-z_]+\s+[A-Z0-9a-z_]+\s+[0-9\.\-]+\s+',line):
                        prm_list[context] += line
                    else:
                        prm_list[context] += "!"+line
                elif context == 4: # DIHEDRALS
                    if re.search(r'^\s*\!+',line,re.I) or \
                       re.search(r'^\s*$',line) or \
                       re.search(r'^\s*[A-Z0-9a-z_]+\s+[A-Z0-9a-z_]+\s+[A-Z0-9a-z_]+\s+[A-Z0-9a-z_]+\s+[0-9\.\-]+\s+',line):
                        prm_list[context] += line
                    else:
                        prm_list[context] += "!"+line
                elif context == 5: # IMPROPER
                    if re.search(r'^\s*\!+',line,re.I) or \
                       re.search(r'^\s*$',line) or \
                       re.search(r'^\s*[A-Z0-9a-z_]+\s+[A-Z0-9a-z_]+\s+[A-Z0-9a-z_]+\s+[A-Z0-9a-z_]+\s+[0-9\.\-]+\s+',line):
                        prm_list[context] += line
                    else:
                        prm_list[context] += "!"+line
                elif context == 6: # CMAP
                    if re.search(r'^\s*\!+',line,re.I) or \
                       re.search(r'^\s*$',line) or \
                       re.search(r'^\s*[A-Z0-9a-z_]+\s+[A-Z0-9a-z_]+\s+[A-Z0-9a-z_]+\s+[A-Z0-9a-z_]+\s+',line) or \
                       re.search(r'^\s*[0-9\.-]+\s+[0-9\.-]+\s+[0-9\.-]+\s+[0-9\.-]+\s+',line):
                        prm_list[context] += line
                    else:
                        prm_list[context] += "!"+line
                elif context == 7: # NONBONDED
                    if re.search(r'^\s*\!+',line,re.I) or \
                       re.search(r'^\s*$',line) or \
                       re.search(r'^\s*[_A-Z0-9a-z\.]+\s+[0-9\.\-]+\s+[0-9\.\-]+\s+',line):
                        prm_list[context] += line
                    else:
                        prm_list[context] += "!"+line
                elif context == 8: # NBFIX
                    if re.search(r'^\s*\!+',line,re.I) or \
                       re.search(r'^\s*$',line) or \
                       re.search(r'^\s*[A-Z0-9a-z_]+\s+[A-Z0-9a-z_]+\s+[0-9\.\-]+\s+',line):
                        prm_list[context] += line
                    else:
                        prm_list[context] += "!"+line
                elif context == 9: # HBOND
                    if not re.search(r'^END',line,re.I):
                        prm_list[context] += line
                else:
                    continue

    prm = ''.join(map(str, prm_list))+"END"
    prmfh = open(outfile, "w")
    prmfh.write(prm)
    prmfh.close()


# Create string to indicate source of section
def _sec_name(filename):
    return "!Following lines added from %s\n" % (filename)


def charmmSplit(filename):
    """ Not implemented yet! Splits a stream file into two rtf and prm files.

    Parameters
    ----------
    filename
    """

    # TODO: Implement this

def _logParser(fname):
    import re
    failedcoor = re.compile('Warning: failed to set coordinate for atom')
    failedangle = re.compile('Warning: failed to guess coordinate due to bad angle')
    poorlycoor = re.compile('Warning: poorly guessed coordinate(s?)')
    otherwarn = re.compile('Warning')

    failedcoorcount = 0
    failedanglecount = 0
    poorlycoorcount = -1  # Discount the summary report message in the log
    otherwarncount = 0
    f = open(fname, 'r')
    for line in f:
        if failedcoor.search(line):
            failedcoorcount += 1
        elif failedangle.search(line):
            failedanglecount += 1
        elif poorlycoor.search(line):
            poorlycoorcount += 1
        elif otherwarn.search(line):
            otherwarncount += 1

    f.close()
    warnings = False
    if failedcoorcount > 0:
        warnings = True
        logger.warning('Failed to set coordinates for {} atoms.'.format(failedcoorcount))
    if failedanglecount > 0:
        warnings = True
        logger.warning('Failed to guess coordinates for {} atoms due to bad angles.'.format(failedanglecount))
    if poorlycoorcount > 0:
        warnings = True
        logger.warning('Poorly guessed coordinates for {} atoms.'.format(poorlycoorcount))
    if otherwarncount > 0:
        warnings = True
        logger.warning('{} undefined warnings were produced during building.'.format(otherwarncount))
    if warnings:
        logger.warning('Failed/poorly guessed coordinates can cause simulations to crash since failed atoms are all positioned on (0,0,0).')
        logger.warning('Please check {} for further information.'.format(fname))
